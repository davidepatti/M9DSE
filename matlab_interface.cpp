
#include "matlab_interface.h"
#include "environment.h"
#include "common.h"
#include <sys/stat.h>

MatlabInterface::MatlabInterface(const string& base_dir)
{
	set_environment(base_dir);
    set_save_matlog(false);
}

MatlabInterface::~MatlabInterface()
{
	cout << "\n Destroying MatlabInterface object...";
}


void MatlabInterface::set_save_matlog(bool save_log)
{
	do_save_log = do_save_log;
}


// Paramters of interested when invoking tcc
// IMPACT: -p to pass parameters file
//


void MatlabInterface::execute_sim(const string &path) //db
{
	char old_path[50];
	getcwd(old_path,50);
	chdir(path.c_str());


	string command;

	command = " ....";

#ifdef DEBUG
	cout << EE_TAG << "executing: " << command;
#endif
	system(command.c_str());
	chdir(old_path);
}

// read statistics from PD_STATS and m5stats.txt files
Dynamic_stats MatlabInterface::get_dynamic_stats(const string& path)
{
    assert(false);
	int x;
	string pd_filename = path + "PD_STATS";

	std::ifstream pd_file(pd_filename.c_str());


	string pippo;
	Dynamic_stats dynamic_stats;
	dynamic_stats.valid = true; // set on false if continue_on_failure occurs

	string logfile = base_path+string(EE_LOG_PATH);
	int myid = get_mpi_rank();

	struct stat st;
	stat(pd_filename.c_str(), &st);

	if (!pd_file)
	{
	    assert(false);

	}
    go_until("Totals",pd_file);
    pippo = skip_to(pd_file,2);
    dynamic_stats.total_cycles = atoll(pippo.erase(0,63));

    pd_file >> pippo;
    dynamic_stats.compute_cycles = atoll(pippo.erase(0,63));


	return dynamic_stats;
}
// extract dynamic statistics from Trimaran PD_STATS file

void MatlabInterface::set_environment(const string& base_dir) {

	this->base_path = base_dir;

	setenv("SUIFPATH","$SUIFPATH:/usr/bin",1);

	string path = getenv("PATH");
	path = path + base_dir + ":" +base_dir+IMPACT_REL_PATH+"/bin:";

// when using mpi multiple processes, some addition paths can be added (see environment.h)
#ifdef EPIC_MPI
	path = MPI_EXPORT_PATH+path;
#endif
	setenv("PATH",path.c_str(),1);


	if (chdir(epic_dir.c_str())==-1)
	{
		string logfile = base_path + string(EE_LOG_PATH);
		int myid = get_mpi_rank();
		write_to_log(myid,logfile,"FATAL ERROR: cannot find "+epic_dir);
		cout << "Cannot find " << epic_dir << endl;
		cout << "Please run ./post_install.sh script from epic explorer dir";
		exit(EXIT_FAILURE);
	}
}

//db

void MatlabInterface::save_model_config(const ModelInverter &p, const string &path) const
{
	string filename = path;
	std::ofstream output_file(filename.c_str());

	if (!output_file)
	{
		string logfile = base_path + string(EE_LOG_PATH);
		int myid = get_mpi_rank();
		write_to_log(myid,logfile,"FATAL ERROR: cannot save hmdes file " + filename);
		exit(EXIT_FAILURE);
	}
	else
	{
		// NOTE:
		// - we assume that rotating and static portion of registers
		// have equal sizes.
		// - All the other parameters are fixed to their default values as specified
		// in the standard trimaran hmdes2 files.

		output_file << "\n// DO NOT EDIT: this file is generated by epic explorer ";
		output_file << "\n// and should be included into the main hmdes2 machine ";
		output_file << "\n// description file using the $include directive";

		output_file << "\n\n";
		output_file << "\n$def !L_d_int\t" << p.L_d_int.get_val();
		output_file << "\n// Register file sizes ";
		output_file << "\n\n";
		output_file << "\n$def !L_g_pin\t" << p.L_g_pin.get_val();
		output_file << "\n$def !L_dH_ext\t" <<   p.L_dH_ext.get_val();
		output_file << "\n$def !L_sH_ext\t" <<    p.L_sH_ext.get_val();
		output_file << "\n$def !L_gH_ext\t" <<    p.L_gH_ext.get_val();
		output_file << "\n$def !L_dL_ext\t" <<   p.L_dL_ext.get_val();


		output_file << "\n$def !L_s_int\t" << p.L_s_int.get_val();
		output_file << "\n$def !L_g_int\t" <<   p.L_g_int.get_val();
		output_file << "\n$def !L_s_pin\t" <<  p.L_s_pin.get_val();
		output_file << "\n$def !L_d_pin\t" <<  p.L_d_pin.get_val();
	}
}

void MatlabInterface::load_model_config(ModelInverter *p, const string &filename) const
{
	std::ifstream input_file(filename.c_str());

	if (!input_file) {
		string logfile = base_path + string(EE_LOG_PATH);
		int myid = get_mpi_rank();
		write_to_log(myid,logfile,"FATAL ERROR: cannot open hmdes file " + filename);
		exit(EXIT_FAILURE);
	}
	else
	{
		int val;
		go_until("!L_d_int",input_file);
		input_file>>val;
		p->L_d_int.set_val(val);

		//Rotating size entries are currently ignored, assuming
		//that rotating portion has always the same size of static
		//portion for all register files.

		/// Register files sizes ////////////////////////////////////
		go_until("!L_g_pin",input_file);
		input_file>>val;
		p->L_g_pin.set_val(val);

		go_until("!L_dH_ext",input_file);
		input_file>>val;
		p->L_dH_ext.set_val(val);

		go_until("!L_sH_ext",input_file);
		input_file>>val;

		p->L_sH_ext.set_val(val);

		go_until("!L_gH_ext",input_file);
		input_file>>val;
		p->L_gH_ext.set_val(val);

		go_until("!L_dL_ext",input_file);
		input_file>>val;
		p->L_dL_ext.set_val(val);

		//// Functional units ////////////////////////

		go_until("!L_s_int",input_file);
		input_file>>val;
		p->L_s_int.set_val(val);

		go_until("!L_g_int",input_file);
		input_file>>val;
		p->L_g_int.set_val(val);

		go_until("!L_s_pin",input_file);
		input_file>>val;
		p->L_s_pin.set_val(val);

		go_until("!L_d_pin",input_file);
		input_file>>val;
		p->L_d_pin.set_val(val);
	}
}


